# Метод filter()

## Основные принципы работы

Метод `filter()` создаёт новый массив, содержащий элементы исходного массива, которые удовлетворяют условию, заданному в callback-функции.

### Ключевые особенности:
- Возвращает новый массив (не изменяет исходный)
- Callback-функция должна возвращать `true` (включить элемент) или `false` (исключить)
- Принимает те же параметры, что и `map()`: элемент, индекс, массив

## Примеры использования

### 1. Фильтрация чисел

```javascript
const numbers = [1, 2, 3, 4, 5, -1, -2, -3];

// Чётные числа
const even = numbers.filter(n => n % 2 === 0);
// [2, 4, -2]

// Отрицательные числа
const negative = numbers.filter(n => n < 0);
// [-1, -2, -3]
```

### 2. Работа с объектами

```javascript
const users = [
  { id: 1, name: 'Анна', age: 25, isActive: true },
  { id: 2, name: 'Иван', age: 30, isActive: false },
  { id: 3, name: 'Мария', age: 35, isActive: true }
];

// Активные пользователи
const activeUsers = users.filter(user => user.isActive);
// [{id: 1, ...}, {id: 3, ...}]

// Пользователи старше 30
const olderThan30 = users.filter(user => user.age > 30);
// [{id: 3, ...}]
```

## Сравнение с другими методами

| Метод | Возвращает | Изменяет исходный | Назначение |
|-------|------------|-------------------|------------|
| filter() | Новый массив | Нет | Фильтрация |
| map() | Новый массив | Нет | Трансформация |
| forEach() | undefined | Да (если мутировать) | Перебор |

## Практические советы

### ✅ Когда использовать:
- Для выборки элементов по условию
- Когда нужно сохранить исходный массив
- Для цепочек методов (chaining)

### ❌ Когда не использовать:
- Если нужен только перебор без фильтрации
- Когда требуется изменить исходный массив
- Для поиска одного элемента (лучше `find()`)

> Метод `filter()` — идеальный инструмент для создания новых массивов на основе условий фильтрации.

