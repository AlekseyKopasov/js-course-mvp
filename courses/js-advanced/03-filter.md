# Метод filter()

## Основные принципы работы

Метод `filter()` создаёт новый массив, содержащий элементы исходного массива, которые удовлетворяют условию, заданному в callback-функции.

### Ключевые особенности:
- Возвращает новый массив (не изменяет исходный)
- Callback-функция должна возвращать `true` (включить элемент) или `false` (исключить)
- Принимает те же параметры, что и `map()`: элемент, индекс, массив

## Примеры использования

### 1. Фильтрация чисел

```javascript
const numbers = [1, 2, 3, 4, 5, -1, -2, -3];

// Чётные числа
const even = numbers.filter(n => n % 2 === 0);
// [2, 4, -2]

// Отрицательные числа
const negative = numbers.filter(n => n < 0);
// [-1, -2, -3]
```

### 2. Работа с объектами

```javascript
const users = [
  { id: 1, name: 'Анна', age: 25, isActive: true },
  { id: 2, name: 'Иван', age: 30, isActive: false },
  { id: 3, name: 'Мария', age: 35, isActive: true }
];

// Активные пользователи
const activeUsers = users.filter(user => user.isActive);
// [{id: 1, ...}, {id: 3, ...}]

// Пользователи старше 30
const olderThan30 = users.filter(user => user.age > 30);
// [{id: 3, ...}]
```

## Сравнение с другими методами

| Метод | Возвращает | Изменяет исходный | Назначение |
|-------|------------|-------------------|------------|
| filter() | Новый массив | Нет | Фильтрация |
| map() | Новый массив | Нет | Трансформация |
| forEach() | undefined | Да (если мутировать) | Перебор |

## Практические советы

### ✅ Когда использовать:
- Для выборки элементов по условию
- Когда нужно сохранить исходный массив
- Для цепочек методов (chaining)

### ❌ Когда не использовать:
- Если нужен только перебор без фильтрации
- Когда требуется изменить исходный массив
- Для поиска одного элемента (лучше `find()`)

> Метод `filter()` — идеальный инструмент для создания новых массивов на основе условий фильтрации.

----

## Домашнее задание

### Уровень 1
**1. Базовая фильтрация чисел**

Дан массив: `[1, -2, 3, -4, 5, -6]`.
Используя `filter`, создайте новый массив, содержащий только положительные числа.

**2. Фильтрация строк по длине**

Дан массив строк: `["cat", "window", "dog", "elephant"]`.  
Создайте новый массив, содержащий только строки длиной более 3 символов.

----

### Уровень 2
**3. Фильтрация объектов по свойству**

Дан массив объектов:
```javascript
const books = [
  { title: "1984", isFiction: true },
  { title: "The Art of War", isFiction: false },
  { title: "Brave New World", isFiction: true }
]
```

Создайте массив, содержащий только художественные книги `(isFiction: true)`.

**4. Комбинированные условия**

Дан массив чисел: `[10, 15, 20, 25, 30, 35, 40]`.
Отфильтруйте числа, которые делятся на **5**, но не делятся на **10**.

----

### Уровень 3
**5. Комплексная фильтрация объектов**

Дан массив пользователей:

```javascript
const users = [
  { id: 1, name: "Anna", age: 25, premium: true },
  { id: 2, name: "Ivan", age: 30, premium: false },
  { id: 3, name: "Maria", age: 17, premium: true }
]
```

Отфильтруйте пользователей, которые:

* Имеют премиум-аккаунт ИЛИ
* Старше 18 лет

**6. Фильтрация по индексу**

Дан массив: `["a", "b", "c", "d", "e", "f"]`.
Создайте новый массив, содержащий только элементы с четными индексами.

----

### Уровень 4
**7. Цепочка методов**

Дан массив товаров:

```javascript
const products = [
  { name: "Laptop", price: 1000, category: "electronics" },
  { name: "Shirt", price: 30, category: "clothing" },
  { name: "Phone", price: 800, category: "electronics" }
]
```

Используя цепочку методов:

* Отфильтруйте электронику
* Преобразуйте цены (добавьте 10%)
* Отфильтруйте товары дороже $900

**8. Фильтрация уникальных значений**

Дан массив с дубликатами: `[1, 2, 2, 3, 4, 4, 5, 5, 5]`.
Создайте новый массив, содержащий только уникальные значения.

----

### Уровень 5
**9. Асинхронный filter**

Реализуйте функцию `asyncFilter`, которая принимает массив и асинхронную функцию-предикат, и возвращает промис с отфильтрованным массивом.

**10. Полифил для filter**

Напишите собственную реализацию метода `filter` (полифил), которая будет работать так же, как стандартный метод.

----

### Бонусное задание
**11. Оптимизация производительности**

Дан очень большой массив (1+ млн элементов).
Напишите оптимальную реализацию фильтрации, учитывающую:

* Минимальное использование памяти
* Возможность отмены операции
