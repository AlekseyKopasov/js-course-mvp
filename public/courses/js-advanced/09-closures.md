# Замыкания

## Основные понятия

**Замыкание** — это функция вместе со всеми внешними переменными, которые ей доступны. В JavaScript функции сохраняют доступ к переменным из того лексического окружения, где они были созданы.

### Лексическое окружение (Lexical Environment)
- Специальный внутренний объект
- Содержит локальные переменные и параметры функции
- Имеет ссылку на внешнее окружение (`[[Scope]]`)

## Как работают замыкания

1. При создании функции она получает скрытое свойство `[[Scope]]`
2. Это свойство ссылается на лексическое окружение, где функция была создана
3. При вызове функции создается новое лексическое окружение
4. Для поиска переменных используется цепочка лексических окружений

## Практические примеры

### 1. Простой счетчик

```javascript
function makeCounter() {
  let count = 0;
  
  return function() {
    return count++;
  };
}

const counter = makeCounter();
console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

### 2. Независимые счетчики

```javascript
const counter1 = makeCounter();
const counter2 = makeCounter();

console.log(counter1()); // 0
console.log(counter1()); // 1
console.log(counter2()); // 0 (независимый счет)
```

### 3. Решение проблемы с циклами и событиями

```javascript
// Проблема (все кнопки выводят 10)
for (var i = 0; i < 10; i++) {
  button.addEventListener('click', function() {
    console.log(i); // Всегда 10
  });
}

// Решение с замыканием
for (var i = 0; i < 10; i++) {
  (function(x) {
    button.addEventListener('click', function() {
      console.log(x); // Правильный индекс
    });
  })(i);
}
```

## Применение замыканий

### 1. Создание приватных переменных

```javascript
function createUser(name) {
  let privateName = name;
  
  return {
    getName() { return privateName; },
    setName(newName) { privateName = newName; }
  };
}

const user = createUser('Анна');
console.log(user.getName()); // "Анна"
```

### 2. Мемоизация (кеширование)

```javascript
function memoize(fn) {
  const cache = {};
  return function(arg) {
    return cache[arg] || (cache[arg] = fn(arg));
  };
}
```

### 3. Каррирование функций

```javascript
function multiply(a) {
  return function(b) {
    return a * b;
  };
}

const double = multiply(2);
console.log(double(5)); // 10
```

## Важные особенности

1. Замыкания могут приводить к утечкам памяти, если неосторожно хранить ссылки на большие объекты
2. В современных версиях JavaScript (ES6+) можно использовать `let/const` в циклах вместо IIFE
3. Замыкания активно используются в модульных системах и паттернах проектирования

> Замыкания — мощный инструмент JavaScript, позволяющий создавать изолированные контексты и сохранять состояние между вызовами функций.

----

## Домашнее задание

### Уровень 1
**1. Простой счетчик**

Создайте функцию `createCounter()`, которая возвращает функцию-счетчик. При каждом вызове счетчик должен увеличивать значение на 1 и возвращать его. Начальное значение - 0.

**2. Сумматор**

Создайте функцию `createAdder(n)`, которая принимает начальное число `n` и возвращает функцию-сумматор. Эта функция должна принимать число `x` и возвращать сумму `n + x`.

----

### Уровень 2
**3. Кэширующий калькулятор**

Создайте функцию `createCachingCalculator()`, которая возвращает объект с методами:
* `add(x)` - возвращает x + 5 и кэширует результат
* `subtract(x)` - возвращает x - 5 и кэширует результат
* `getCache()` - возвращает объект с кэшем

**4. Генератор последовательностей**

Создайте функцию `sequenceGenerator(start, step)`, которая возвращает функцию-генератор. При каждом вызове генератор возвращает следующее число в арифметической прогрессии (начальное значение `start`, шаг `step`).

----

### Уровень 3
**5. Частичное применение**

Реализуйте функцию `partial(fn, ...args)`, которая принимает функцию `fn` и начальные аргументы, возвращая новую функцию. При вызове новой функции с дополнительными аргументами, она должна вызвать `fn` со всеми аргументами.

**6. Логирование вызовов**

Создайте функцию `createLoggedFunc(fn)`, которая принимает функцию `fn` и возвращает новую функцию. Новая функция должна:
* Логировать все аргументы при вызове
* Логировать результат выполнения
* Возвращать тот же результат, что и `fn`

----

### Уровень 4
**7. Мемоизация сложной функции**

Реализуйте функцию `memoize(fn)`, которая кэширует результаты вызовов `fn` для любых аргументов. Учтите, что аргументы могут быть объектами - их нужно правильно сравнивать.

**8. Композиция функций**

Создайте функцию `compose(...fns)`, которая принимает несколько функций и возвращает новую функцию. Новая функция должна применять все функции справа налево к переданному аргументу.

----

### Уровень 5
**9. Асинхронное замыкание**

Создайте функцию `asyncSequence(generatorFn)`, которая принимает асинхронную функцию-генератор и возвращает объект с методами:
* `next()` - возвращает Promise со следующим значением
* `isDone()` - проверяет, завершена ли последовательность

**10. Защищенный объект**

Реализуйте функцию `createProtectedObject(obj, password)`, которая возвращает прокси-объект. Доступ к свойствам исходного объекта должен быть только после вызова `unlock(password)`.

----

### Бонусное задание
**11. Реализация модуля**

Создайте аналог модуля ES6 с помощью замыканий:
* Приватные переменные
* Публичные методы
* Возможность расширения
