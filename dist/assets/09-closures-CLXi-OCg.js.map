{"version":3,"file":"09-closures-CLXi-OCg.js","sources":["../../src/entities/lecture/assets/lectures/09-closures.md"],"sourcesContent":["# Замыкания\n\n## Основные понятия\n\n**Замыкание** — это функция вместе со всеми внешними переменными, которые ей доступны. В JavaScript функции сохраняют доступ к переменным из того лексического окружения, где они были созданы.\n\n### Лексическое окружение (Lexical Environment)\n- Специальный внутренний объект\n- Содержит локальные переменные и параметры функции\n- Имеет ссылку на внешнее окружение (`[[Scope]]`)\n\n## Как работают замыкания\n\n1. При создании функции она получает скрытое свойство `[[Scope]]`\n2. Это свойство ссылается на лексическое окружение, где функция была создана\n3. При вызове функции создается новое лексическое окружение\n4. Для поиска переменных используется цепочка лексических окружений\n\n## Практические примеры\n\n### 1. Простой счетчик\n\n```javascript\nfunction makeCounter() {\n  let count = 0;\n  \n  return function() {\n    return count++;\n  };\n}\n\nconst counter = makeCounter();\nconsole.log(counter()); // 0\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\n```\n\n### 2. Независимые счетчики\n\n```javascript\nconst counter1 = makeCounter();\nconst counter2 = makeCounter();\n\nconsole.log(counter1()); // 0\nconsole.log(counter1()); // 1\nconsole.log(counter2()); // 0 (независимый счет)\n```\n\n### 3. Решение проблемы с циклами и событиями\n\n```javascript\n// Проблема (все кнопки выводят 10)\nfor (var i = 0; i < 10; i++) {\n  button.addEventListener('click', function() {\n    console.log(i); // Всегда 10\n  });\n}\n\n// Решение с замыканием\nfor (var i = 0; i < 10; i++) {\n  (function(x) {\n    button.addEventListener('click', function() {\n      console.log(x); // Правильный индекс\n    });\n  })(i);\n}\n```\n\n## Применение замыканий\n\n### 1. Создание приватных переменных\n\n```javascript\nfunction createUser(name) {\n  let privateName = name;\n  \n  return {\n    getName() { return privateName; },\n    setName(newName) { privateName = newName; }\n  };\n}\n\nconst user = createUser('Анна');\nconsole.log(user.getName()); // \"Анна\"\n```\n\n### 2. Мемоизация (кеширование)\n\n```javascript\nfunction memoize(fn) {\n  const cache = {};\n  return function(arg) {\n    return cache[arg] || (cache[arg] = fn(arg));\n  };\n}\n```\n\n### 3. Каррирование функций\n\n```javascript\nfunction multiply(a) {\n  return function(b) {\n    return a * b;\n  };\n}\n\nconst double = multiply(2);\nconsole.log(double(5)); // 10\n```\n\n## Важные особенности\n\n1. Замыкания могут приводить к утечкам памяти, если неосторожно хранить ссылки на большие объекты\n2. В современных версиях JavaScript (ES6+) можно использовать `let/const` в циклах вместо IIFE\n3. Замыкания активно используются в модульных системах и паттернах проектирования\n\n> Замыкания — мощный инструмент JavaScript, позволяющий создавать изолированные контексты и сохранять состояние между вызовами функций.\n\n"],"names":["_09Closures"],"mappings":"AAAA,MAAAA,EAAe"}